### Guards

Guard adalah sebuah kelas yang diberi anotasi dengan decorator `@Injectable()`, yang mengimplementasikan antarmuka `CanActivate`.

<figure><img src="https://docs.nestjs.com/assets/Guards_1.png" /></figure>

Guard memiliki **tanggung jawab tunggal**. Mereka menentukan apakah suatu permintaan tertentu akan ditangani oleh penangan rute atau tidak, tergantung pada kondisi-kondisi tertentu (seperti izin, peran, ACL, dll.) yang ada pada saat runtime. Ini sering disebut sebagai **otorisasi**. Otorisasi (dan saudaranya, **autentikasi**, yang biasanya bekerja sama dengannya) biasanya ditangani oleh [middleware](/middleware) dalam aplikasi Express tradisional. Middleware adalah pilihan yang tepat untuk autentikasi, karena hal-hal seperti validasi token dan menambahkan properti ke objek `request` tidak terlalu terkait dengan konteks rute tertentu (dan metadata-nya).

Namun, middleware, secara alamiah, tidak cerdas. Itu tidak tahu penangan mana yang akan dieksekusi setelah memanggil fungsi `next()`. Di sisi lain, **Guards** memiliki akses ke instance `ExecutionContext`, dan dengan demikian tahu persis apa yang akan dieksekusi selanjutnya. Mereka dirancang, mirip dengan exception filters, pipes, dan interceptors, untuk memungkinkan Anda menyisipkan logika pemrosesan pada titik yang tepat dalam siklus permintaan/respons, dan melakukannya secara deklaratif. Ini membantu menjaga kode Anda DRY dan deklaratif.

> info **Hint** Guards dieksekusi **setelah** semua middleware, tetapi **sebelum** interceptor atau pipe mana pun.

#### Guard otorisasi

Seperti yang disebutkan, **otorisasi** adalah kasus penggunaan yang sangat baik untuk Guards karena rute-rute tertentu harus tersedia hanya ketika pemanggil (biasanya pengguna yang terautentikasi tertentu) memiliki izin yang cukup. `AuthGuard` yang akan kita bangun sekarang mengasumsikan pengguna yang terautentikasi (dan bahwa, oleh karena itu, sebuah token terlampir pada header permintaan). Ini akan mengekstrak dan memvalidasi token, serta menggunakan informasi yang diekstraksi untuk menentukan apakah permintaan dapat dilanjutkan atau tidak.

```typescript
@@filename(auth.guard)
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}
```

> info **Hint** Jika Anda mencari contoh dunia nyata tentang bagaimana mengimplementasikan mekanisme autentikasi dalam aplikasi Anda, kunjungi [bab ini](/security/authentication). Begitu juga, untuk contoh otorisasi yang lebih canggih, periksa [halaman ini](/security/authorization).

Logika di dalam fungsi `validateRequest()` dapat sederhana atau kompleks sesuai kebutuhan. Titik utama dari contoh ini adalah untuk menunjukkan bagaimana Guards berfungsi dalam siklus permintaan/respons.

Setiap guard harus mengimplementasikan fungsi `canActivate()`. Fungsi ini harus mengembalikan nilai boolean, yang menunjukkan apakah permintaan saat ini diizinkan atau tidak. Ini dapat mengembalikan respons baik secara sinkron atau asinkron (melalui `Promise` atau `Observable`). Nest menggunakan nilai kembalian ini untuk mengontrol tindakan selanjutnya:

- jika mengembalikan `true`, permintaan akan diproses.
- jika mengembalikan `false`, Nest akan menolak permintaan tersebut.
