### Pipes

Sebuah pipe adalah sebuah kelas yang dianotasi dengan dekorator `@Injectable()`, yang mengimplementasikan antarmuka `PipeTransform`.

<figure>
  <img src="https://docs.nestjs.com/assets/Pipe_1.png" />
</figure>

Pipes memiliki dua kasus penggunaan umum:

- **transformasi**: mengubah data input ke bentuk yang diinginkan (misalnya, dari string ke integer)
- **validasi**: mengevaluasi data input, jika valid, dilewatkan tanpa perubahan; jika tidak, lemparkan pengecualian

Dalam kedua kasus ini, pipes beroperasi pada `arguments` yang diproses oleh <a href="controllers#route-parameters">handler rute controller</a>. Nest memasukkan pipe tepat sebelum suatu metode dipanggil, dan pipe menerima argumen yang dituju untuk metode dan beroperasi pada mereka. Operasi transformasi atau validasi berlangsung pada saat itu, setelah itu handler rute dipanggil dengan argumen yang (mungkin) sudah diubah.

Nest dilengkapi dengan sejumlah pipe bawaan yang dapat Anda gunakan langsung. Anda juga dapat membangun pipe kustom sendiri. Dalam bab ini, kami akan memperkenalkan pipe bawaan dan menunjukkan cara mengikatnya ke handler rute. Kami juga akan menguji beberapa pipe kustom untuk menunjukkan bagaimana Anda bisa membangun satu dari awal.

> info **Hint** Pipes berjalan di dalam zona pengecualian. Ini berarti saat sebuah pipe melempar pengecualian, itu ditangani oleh lapisan pengecualian (penyaring pengecualian global dan setiap [penyaring pengecualian](/exception-filters) yang diterapkan pada konteks saat ini). Dengan demikian, ketika pengecualian dilemparkan dalam sebuah pipe, metode controller tidak akan dieksekusi secara berikutnya. Ini memberi Anda teknik praktik terbaik untuk memvalidasi data yang masuk ke aplikasi dari sumber eksternal pada batas sistem.

#### Built-in Pipes

Nest dilengkapi dengan sembilan pipes yang tersedia secara langsung:

- `ValidationPipe`
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`
- `ParseFilePipe`

Semua ini diekspor dari paket `@nestjs/common`.

Mari kita lihat penggunaan `ParseIntPipe` sebagai contoh kasus **transformasi**, di mana pipe memastikan bahwa parameter handler metode dikonversi menjadi integer JavaScript (atau melemparkan pengecualian jika konversi gagal). Nanti dalam bab ini, kita akan menunjukkan implementasi kustom sederhana untuk `ParseIntPipe`. Teknik-teknik contoh di bawah ini juga berlaku untuk pipe transformasi bawaan lainnya (`ParseBoolPipe`, `ParseFloatPipe`, `ParseEnumPipe`, `ParseArrayPipe`, dan `ParseUUIDPipe`), yang akan kita sebut sebagai pipa `Parse*` dalam bab ini.

#### Mengikat Pipes (Binding pipes)

Untuk menggunakan pipe, kita perlu mengikat instance kelas pipe ke konteks yang sesuai. Pada contoh `ParseIntPipe` kita, kita ingin mengaitkan pipe dengan metode handler rute tertentu, dan memastikan pipe berjalan sebelum metode dipanggil. Ini dilakukan dengan konstruksi berikut, yang akan kita sebut sebagai mengikat pipa pada level parameter metode:

```typescript
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

Ini memastikan bahwa salah satu dari dua kondisi berikut benar: entah parameter yang kita terima dalam metode `findOne()` adalah sebuah angka (seperti yang diharapkan dalam panggilan `this.catsService.findOne()`), atau sebuah pengecualian dilemparkan sebelum handler rute dipanggil.

Misalnya, asumsikan rute dipanggil seperti ini:

```bash
GET localhost:3000/abc
```

Nest akan melempar pengecualian seperti ini:

```json
{
  "statusCode": 400,
  "message": "Validasi gagal (diharapkan string numerik)",
  "error": "Permintaan Buruk"
}
```

Pengecualian ini akan mencegah eksekusi tubuh metode `findOne()`.

Dalam contoh di atas, kita melewati sebuah kelas (`ParseIntPipe`), bukan sebuah instance, meninggalkan tanggung jawab untuk instansiasi kepada kerangka kerja dan memungkinkan injeksi dependensi. Seperti halnya dengan pipes dan guards, kita juga dapat melewati instance tempat dalam pipa. Melewati instance tempat berguna jika kita ingin menyesuaikan perilaku pipa bawaan dengan melewati opsi:

```typescript
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}
```

Mengikat pipa transformasi lainnya (semua pipa **Parse\***) bekerja dengan cara yang sama. Pipa-pipa ini semua beroperasi dalam konteks memvalidasi parameter rute, parameter string query, dan nilai body permintaan.

Sebagai contoh dengan parameter string query:

```typescript
@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

Berikut contoh penggunaan `ParseUUIDPipe` untuk mengurai parameter string dan memvalidasi apakah itu UUID.

```typescript
@@filename()
@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}
@@switch
@Get(':uuid')
@Bind(Param('uuid', new ParseUUIDPipe()))
async findOne(uuid) {
  return this.catsService.findOne(uuid);
}
```

> info **Hint** Ketika menggunakan `ParseUUIDPipe()` Anda sedang mengurai UUID dalam versi 3, 4, atau 5, jika Anda hanya membutuhkan versi UUID tertentu Anda dapat melewati versi dalam opsi pipa.

Di atas, kita telah melihat contoh mengikat berbagai pipa `Parse*` bawaan. Mengikat pipa validasi sedikit berbeda; kita akan membahas itu di bagian berikutnya.

> info **Hint** Lihat juga [Teknik Validasi](/techniques/validation) untuk contoh yang luas tentang pipa validasi.

#### Pipes Kustom (Custom pipes)

Seperti yang telah disebutkan, Anda dapat membangun pipa kustom sendiri. Meskipun Nest menyediakan `ParseIntPipe` dan `ValidationPipe` bawaan yang kuat, mari kita bangun versi kustom sederhana dari masing-masing dari awal untuk melihat bagaimana pipa kustom dibuat.

Kita mulai dengan `ValidationPipe` sederhana. Awalnya, kita akan membuatnya hanya mengambil nilai input dan segera mengembalikan nilai yang sama, berperilaku seperti fungsi identitas.

```typescript
@@filename(validation.pipe)
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
@@switch
import { Injectable } from '@nestjs/common';

@Injectable()
export class ValidationPipe {
  transform(value, metadata) {
    return value;
  }
}
```

> info **Petunjuk** `PipeTransform<T, R>` adalah antarmuka generik yang harus diimplementasikan oleh setiap pipa. Antarmuka generik menggunakan `T` untuk menunjukkan tipe dari input `value`, dan `R` untuk menunjukkan tipe pengembalian dari metode `transform()`.

Setiap pipa harus mengimplementasikan metode `transform()` untuk memenuhi kontrak antarmuka `PipeTransform`. Metode ini memiliki dua parameter:

- `value`
- `metadata`

Parameter `value` adalah argumen metode yang sedang diproses (sebelum diterima oleh metode penanganan rute), dan `metadata` adalah metadata argumen metode yang sedang diproses. Objek metadata memiliki properti-properti ini:

```typescript
export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom';
  metatype?: Type<unknown>;
  data?: string;
}
```

Properti-properti ini menjelaskan argumen yang sedang diproses.

<table>
  <tr>
    <td>
      <code>type</code>
    </td>
    <td>Menunjukkan apakah argumen adalah body
      <code>@Body()</code>, query
      <code>@Query()</code>, param
      <code>@Param()</code>, atau parameter kustom (baca lebih lanjut
      <a routerLink="/custom-decorators">di sini</a>).</td>
  </tr>
  <tr>
    <td>
      <code>metatype</code>
    </td>
    <td>
      Memberikan metatype dari argumen, misalnya,
      <code>String</code>. Catatan: nilai ini
      <code>undefined</code> jika Anda mengabaikan deklarasi tipe dalam tanda tangan metode penangan rute, atau menggunakan JavaScript biasa.
    </td>
  </tr>
  <tr>
    <td>
      <code>data</code>
    </td>
    <td>String yang diteruskan ke dekorator, misalnya
      <code>@Body('string')</code>. Nilainya
      <code>undefined</code> jika Anda membiarkan tanda kurung dekorator kosong.</td>
  </tr>
</table>

> warning **Peringatan** Antarmuka TypeScript menghilang selama transpiling. Jadi, jika tipe parameter metode dinyatakan sebagai antarmuka alih-alih kelas, nilai `metatype` akan menjadi `Object`.
