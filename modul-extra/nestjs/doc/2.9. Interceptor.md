### Interceptor

Sebuah interceptor adalah sebuah kelas yang dianotasi dengan dekorator `@Injectable()` dan mengimplementasikan antarmuka `NestInterceptor`.

<figure><img src="https://docs.nestjs.com/assets/Interceptors_1.png" /></figure>

Interceptor memiliki serangkaian kemampuan yang berguna yang terinspirasi dari teknik [Aspect Oriented Programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming) (AOP). Mereka memungkinkan untuk:

- mengikat logika tambahan sebelum / setelah eksekusi metode
- mentransformasi hasil yang dikembalikan dari sebuah fungsi
- mentransformasi pengecualian yang dilemparkan dari sebuah fungsi
- memperluas perilaku dasar fungsi
- mengganti fungsi sepenuhnya tergantung pada kondisi khusus (misalnya, untuk tujuan caching)

#### Dasar-dasar

Setiap interceptor mengimplementasikan metode `intercept()`, yang menerima dua argumen. Argumen pertama adalah instance `ExecutionContext` (sama persis seperti untuk [guards](/guards)). `ExecutionContext` mewarisi dari `ArgumentsHost`. Kita telah melihat `ArgumentsHost` sebelumnya dalam bab filter pengecualian. Di sana, kita melihat bahwa ini adalah pembungkus yang berisi argumen yang telah dilewatkan ke handler asli, dan berisi array argumen yang berbeda berdasarkan jenis aplikasi. Anda dapat merujuk kembali ke [filter pengecualian](https://docs.nestjs.com/exception-filters#arguments-host) untuk lebih lanjut tentang topik ini.

#### Konteks eksekusi

Dengan memperluas `ArgumentsHost`, `ExecutionContext` juga menambahkan beberapa metode bantu baru yang memberikan detail tambahan tentang proses eksekusi saat ini. Detail ini dapat membantu dalam membangun interceptor yang lebih generik yang dapat bekerja di sejumlah besar kontroler, metode, dan konteks eksekusi. Pelajari lebih lanjut tentang `ExecutionContext` [di sini](/fundamentals/execution-context).

#### Panggilan handler

Argumen kedua adalah `CallHandler`. Antarmuka `CallHandler` mengimplementasikan metode `handle()`, yang dapat Anda gunakan untuk memanggil metode handler rute pada suatu titik dalam interceptor Anda. Jika Anda tidak memanggil metode `handle()` dalam implementasi metode `intercept()`, metode handler rute tidak akan dieksekusi sama sekali.

Pendekatan ini berarti bahwa metode `intercept()` efektif **melilit** aliran permintaan/respons. Akibatnya, Anda dapat menulis logika kustom **baik sebelum maupun setelah** eksekusi handler rute akhir. Jelas bahwa Anda dapat menulis kode dalam metode `intercept()` yang dieksekusi **sebelum** memanggil `handle()`, namun bagaimana Anda mempengaruhi apa yang terjadi setelahnya? Karena metode `handle()` mengembalikan sebuah `Observable`, kita dapat menggunakan operator [RxJS](https://github.com/ReactiveX/rxjs) yang kuat untuk memanipulasi respons lebih lanjut. Menggunakan istilah Aspect Oriented Programming, pemanggilan handler rute (yaitu, memanggil `handle()`) disebut [Pointcut](https://en.wikipedia.org/wiki/Pointcut), menandakan bahwa inilah titik di mana logika tambahan kami dimasukkan.

Sebagai contoh, pertimbangkan permintaan `POST /cats` yang masuk. Permintaan ini ditujukan ke handler `create()` yang didefinisikan di dalam `CatsController`. Jika sebuah interceptor yang tidak memanggil metode `handle()` dipanggil di sepanjang jalan, metode `create()` tidak akan dieksekusi. Begitu `handle()` dipanggil (dan `Observable`-nya telah dikembalikan), handler `create()` akan dipicu. Dan setelah aliran respons diterima melalui `Observable`, operasi tambahan dapat dilakukan pada aliran tersebut, dan hasil akhir dikembalikan kepada pemanggil.
