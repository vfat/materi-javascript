### Filter Pengecualian

Nest dilengkapi dengan **lapisan pengecualian** bawaan yang bertanggung jawab untuk memproses semua pengecualian yang tidak tertangani di seluruh aplikasi. Ketika pengecualian tidak ditangani oleh kode aplikasi Anda, pengecualian tersebut ditangkap oleh lapisan ini, yang kemudian secara otomatis mengirimkan respons yang ramah pengguna.

<figure>
  <img src="https://docs.nestjs.com/assets/Filter_1.png" />
</figure>

Secara default, tindakan ini dilakukan oleh **filter pengecualian global** bawaan, yang menangani pengecualian jenis `HttpException` (dan subkelasnya). Ketika pengecualian **tidak dikenal** (bukan `HttpException` atau kelas yang mewarisi dari `HttpException`), filter pengecualian bawaan menghasilkan respons JSON default berikut:

```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

> info **Petunjuk** Filter pengecualian global sebagian mendukung pustaka `http-errors`. Pada dasarnya, pengecualian yang dilemparkan yang berisi properti `statusCode` dan `message` akan diisi dan dikirim kembali sebagai respons (alih-alih `InternalServerErrorException` default untuk pengecualian yang tidak dikenal).

#### Melempar pengecualian standar

Nest menyediakan kelas `HttpException` bawaan, diekspos dari paket `@nestjs/common`. Untuk aplikasi berbasis API HTTP REST/GraphQL yang umum, praktik terbaik adalah mengirim objek respons HTTP standar ketika kondisi kesalahan tertentu terjadi.

Misalnya, di `CatsController`, kami memiliki metode `findAll()` (penangan rute `GET`). Misalkan penangan rute ini melemparkan pengecualian karena suatu alasan. Untuk mendemonstrasikan ini, kami akan mengkodenya sebagai berikut:

```typescript
@@filename(cats.controller)
@Get()
async findAll() {
  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
}
```

> info **Petunjuk** Kami menggunakan `HttpStatus` di sini. Ini adalah enum pembantu yang diimpor dari paket `@nestjs/common`.

Ketika klien memanggil titik akhir ini, responsnya terlihat seperti ini:

```json
{
  "statusCode": 403,
  "message": "Forbidden"
}
```

Konstruktor `HttpException` mengambil dua argumen wajib yang menentukan respons:

- Argumen `response` mendefinisikan tubuh respons JSON. Ini bisa berupa `string` atau `object` seperti dijelaskan di bawah ini.
- Argumen `status` mendefinisikan [kode status HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

Secara default, tubuh respons JSON berisi dua properti:

- `statusCode`: default ke kode status HTTP yang diberikan dalam argumen `status`
- `message`: deskripsi singkat dari kesalahan HTTP berdasarkan `status`

Untuk mengganti bagian pesan dari tubuh respons JSON, berikan string dalam argumen `response`. Untuk mengganti seluruh tubuh respons JSON, berikan objek dalam argumen `response`. Nest akan menyerialisasikan objek tersebut dan mengembalikannya sebagai tubuh respons JSON.

Argumen konstruktor kedua - `status` - harus berupa kode status HTTP yang valid. Praktik terbaik adalah menggunakan enum `HttpStatus` yang diimpor dari `@nestjs/common`.

Ada argumen konstruktor **ketiga** (opsional) - `options` - yang dapat digunakan untuk memberikan [penyebab kesalahan](https://nodejs.org/en/blog/release/v16.9.0/#error-cause). Objek `cause` ini tidak diserialisasikan ke dalam objek respons, tetapi dapat berguna untuk tujuan pencatatan, memberikan informasi berharga tentang kesalahan internal yang menyebabkan `HttpException` dilemparkan.

Berikut adalah contoh mengganti seluruh tubuh respons dan memberikan penyebab kesalahan:

```typescript
@@filename(cats.controller)
@Get()
async findAll() {
  try {
    await this.service.findAll()
  } catch (error) {
    throw new HttpException({
      status: HttpStatus.FORBIDDEN,
      error: 'This is a custom message',
    }, HttpStatus.FORBIDDEN, {
      cause: error
    });
  }
}
```

Menggunakan contoh di atas, ini adalah bagaimana respons akan terlihat:

```json
{
  "status": 403,
  "error": "This is a custom message"
}
```

#### Pengecualian kustom

Dalam banyak kasus, Anda tidak perlu menulis pengecualian kustom, dan dapat menggunakan pengecualian HTTP bawaan Nest, seperti yang dijelaskan di bagian berikut. Jika Anda memang perlu membuat pengecualian yang disesuaikan, adalah praktik yang baik untuk membuat **hierarki pengecualian** Anda sendiri, di mana pengecualian kustom Anda mewarisi dari kelas dasar `HttpException`. Dengan pendekatan ini, Nest akan mengenali pengecualian Anda, dan secara otomatis menangani respons kesalahan. Mari kita terapkan pengecualian kustom seperti itu:

```typescript
@@filename(forbidden.exception)
export class ForbiddenException extends HttpException {
  constructor() {
    super('Forbidden', HttpStatus.FORBIDDEN);
  }
}
```

Karena `ForbiddenException` memperluas kelas dasar `HttpException`, ia akan bekerja tanpa masalah dengan penangan pengecualian bawaan, dan oleh karena itu kita dapat menggunakannya di dalam metode `findAll()`.

```typescript
@@filename(cats.controller)
@Get()
async findAll() {
  throw new ForbiddenException();
}
```

#### Pengecualian HTTP bawaan

Nest menyediakan serangkaian pengecualian standar yang mewarisi dari kelas dasar `HttpException`. Pengecualian ini diekspos dari paket `@nestjs/common`, dan mewakili banyak pengecualian HTTP yang paling umum:

- `BadRequestException`
- `UnauthorizedException`
- `NotFoundException`
- `ForbiddenException`
- `NotAcceptableException`
- `RequestTimeoutException`
- `ConflictException`
- `GoneException`
- `HttpVersionNotSupportedException`
- `PayloadTooLargeException`
- `UnsupportedMediaTypeException`
- `UnprocessableEntityException`
- `InternalServerErrorException`
- `NotImplementedException`
- `ImATeapotException`
- `MethodNotAllowedException`
- `BadGatewayException`
- `ServiceUnavailableException`
- `GatewayTimeoutException`
- `PreconditionFailedException`

Semua pengecualian bawaan juga dapat memberikan baik penyebab kesalahan dan deskripsi kesalahan menggunakan parameter `options`:

```typescript
throw new BadRequestException('Something bad happened', { cause: new Error(), description: 'Some error description' })
```

Menggunakan contoh di atas, ini adalah bagaimana respons akan terlihat:

```json
{
  "message": "Something bad happened",
  "error": "Some error description",
  "statusCode": 400,
}
```

#### Filter pengecualian

Sementara filter pengecualian bawaan dapat secara otomatis menangani banyak kasus untuk Anda, Anda mungkin ingin **kendali penuh** atas lapisan pengecualian. Misalnya, Anda mungkin ingin menambahkan pencatatan atau menggunakan skema JSON yang berbeda berdasarkan beberapa faktor dinamis. **Filter pengecualian** dirancang untuk tujuan ini. Mereka memungkinkan Anda mengendalikan alur kendali dan konten respons yang dikirim kembali ke klien.

Mari kita buat filter pengecualian yang bertanggung jawab untuk menangkap pengecualian yang merupakan instance dari kelas `HttpException`, dan mengimplementasikan logika respons kustom untuk mereka. Untuk melakukan ini, kita akan perlu mengakses objek `Request` dan `Response` platform yang mendasari. Kita akan mengakses objek `Request` sehingga kita dapat mengambil `url` asli dan menyertakannya dalam informasi pencatatan. Kita akan menggunakan objek `Response` untuk mengendalikan langsung respons yang dikirim, menggunakan metode `response.json()`.

```typescript
@@filename(http-exception.filter)
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
@@switch
import { Catch, HttpException } from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter {
  catch(exception, host) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
```

> info **Petunjuk** Semua filter pengecualian harus mengimplementasikan antarmuka generik `ExceptionFilter<T>`. Ini mengharuskan Anda menyediakan metode `catch(exception: T, host: ArgumentsHost)` dengan tanda tangannya yang ditunjukkan. `T` menunjukkan jenis pengecualian.

> warning **Peringatan** Jika Anda menggunakan `@nestjs/platform-fastify` Anda dapat menggunakan `response.send()` alih-alih `response.json()`. Jangan lupa mengimpor tipe yang benar

 dari `fastify` (misalnya, `FastifyRequest`, `FastifyReply`).

Filter pengecualian kami diatur untuk menangkap pengecualian yang merupakan instance dari kelas `HttpException`. `@Catch(HttpException)` menunjukkan bahwa filter ini menangkap pengecualian `HttpException`. `ArgumentsHost` adalah objek utilitas yang memberikan metode untuk beralih antara beberapa jenis konteks. Dengan aplikasi HTTP, kami tertarik pada konteks HTTP, jadi kami memanggil `host.switchToHttp()` untuk mengubah ke konteks HTTP.

Setelah memiliki `ctx`, kami dapat mengambil objek `response` dan `request` yang mendasari. Dari sana, kami mengambil `status` dari pengecualian yang telah dilemparkan.

Akhirnya, kami menggunakan objek respons yang mendasari untuk menetapkan kode status, bersama dengan objek JSON yang berisi status respons (statusCode), cap waktu (timestamp), dan jalur yang diminta (path).

#### Mengikat filter pengecualian

Filter pengecualian bisa **global-scope, controller-scoped**, atau **method-scoped**. Mari kita mulai dengan contoh global-scope.

##### Global-scoped

Untuk mendeklarasikan filter pengecualian global-scoped, kita menggunakan metode `useGlobalFilters()` milik kelas aplikasi utama, seperti yang ditunjukkan di bawah ini:

```typescript
@@filename(main)
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { HttpExceptionFilter } from './http-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(3000);
}
bootstrap();
```

Filter pengecualian global akan menangkap semua pengecualian di seluruh aplikasi.

##### Controller-scoped

Untuk menetapkan filter pengecualian pada controller tertentu, kita menggunakan dekorator `@UseFilters()`. `@UseFilters()` mengambil satu (atau beberapa) kelas filter pengecualian, seperti yang ditunjukkan di bawah ini:

```typescript
@@filename(cats.controller)
import { Controller, Get, UseFilters } from '@nestjs/common';
import { HttpExceptionFilter } from './http-exception.filter';

@Controller('cats')
@UseFilters(HttpExceptionFilter)
export class CatsController {
  @Get()
  async findAll() {
    throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
  }
}
```

Sekarang, filter pengecualian `HttpExceptionFilter` hanya akan menangkap pengecualian untuk tindakan dalam `CatsController`.

##### Method-scoped

Untuk menetapkan filter pengecualian pada metode rute tertentu, kita menetapkan dekorator `@UseFilters()` di atas metode rute yang dimaksud, seperti yang ditunjukkan di bawah ini:

```typescript
@@filename(cats.controller)
import { Controller, Get, UseFilters } from '@nestjs/common';
import { HttpExceptionFilter } from './http-exception.filter';

@Controller('cats')
export class CatsController {
  @Get()
  @UseFilters(HttpExceptionFilter)
  async findAll() {
    throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
  }
}
```

#### Filter pengecualian generik

Filter pengecualian dapat menangkap lebih dari satu jenis pengecualian. Jika tidak ada pengecualian yang disediakan di dekorator `@Catch()`, filter pengecualian akan menangkap setiap pengecualian yang dilemparkan. Pengecualian adalah variabel polimorfik di filter pengecualian generik.

```typescript
@@filename(any-exception.filter)
import { ExceptionFilter, Catch, ArgumentsHost } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class AnyExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus?.() || 500;

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
```

Pada contoh di atas, `AnyExceptionFilter` menangkap semua pengecualian. Pengecualian dapat berupa objek **apa saja**. Jika objek pengecualian memiliki metode `getStatus()`, metode itu dipanggil untuk mendapatkan status pengecualian, atau jika tidak, kode status default adalah 500.

Mari kita tentukan filter pengecualian generik pada scope aplikasi:

```typescript
@@filename(main)
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AnyExceptionFilter } from './any-exception.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new AnyExceptionFilter());
  await app.listen(3000);
}
bootstrap();
```

#### Filter pengecualian untuk GraphQL

Untuk menentukan filter pengecualian untuk GraphQL, kita perlu mengakses objek `exception` dan menyertakan objek `ArgumentsHost`. Untuk mengambil objek `exception` kita perlu mengakses metode `getContext()`, dan kemudian kita bisa menggunakan `host.switchToHttp().getResponse()`. 

Berikut adalah contoh filter pengecualian yang dapat digunakan untuk GraphQL:

```typescript
@@filename(gql-exception.filter)
import { Catch, ArgumentsHost } from '@nestjs/common';
import { GqlExceptionFilter } from '@nestjs/graphql';

@Catch()
export class GqlHttpExceptionFilter implements GqlExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const gqlHost = GqlArgumentsHost.create(host);
    return exception;
  }
}
```

Untuk mengikat filter pengecualian pada metode rute, controller, atau scope aplikasi, kita bisa menggunakan metode `useGlobalFilters()` pada objek aplikasi utama atau dekorator `@UseFilters()` seperti yang telah dijelaskan sebelumnya.

Filter pengecualian memberikan kendali penuh atas alur kendali dan konten respons yang dikirim kembali ke klien, memungkinkan kita untuk menyesuaikan respons kesalahan dengan cara yang paling sesuai dengan kebutuhan aplikasi kita.
