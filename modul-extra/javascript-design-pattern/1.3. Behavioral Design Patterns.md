Behavioral Design Patterns adalah pola desain yang menangani komunikasi, aliran kontrol, dan tanggung jawab antara objek-objek yang berbeda dalam aplikasi atau sistem. Pola ini fokus pada bagaimana objek-objek saling berinteraksi dan berkomunikasi untuk menyelesaikan tugas-tugas tertentu dengan cara yang terstruktur dan fleksibel. Tujuan dari Behavioral Design Patterns adalah untuk memudahkan pengelolaan kompleksitas interaksi objek dan meningkatkan fleksibilitas serta keterbacaan kode.

Secara umum, Behavioral Design Patterns dapat dibagi menjadi beberapa kategori berdasarkan fokus dan tujuannya:

### 1. **Chain of Responsibility Pattern**
   - Memungkinkan serangkaian objek untuk menangani permintaan berurutan.
   - Contoh: Middleware dalam Express.js untuk menangani permintaan HTTP.

### 2. **Command Pattern**
   - Mengubah permintaan atau operasi menjadi objek mandiri.
   - Contoh: Tombol pada GUI yang mengeksekusi perintah yang berbeda.

### 3. **Iterator Pattern**
   - Memberikan cara untuk mengakses elemen-elemen objek koleksi secara berurutan tanpa mengetahui detail implementasinya.
   - Contoh: Iterasi melalui elemen-elemen dalam array.

### 4. **Mediator Pattern**
   - Mengatur komunikasi antara objek-objek yang saling terkait tanpa harus secara langsung berinteraksi.
   - Contoh: Penggunaan mediator dalam sistem GUI untuk mengatur interaksi antara elemen GUI.

### 5. **Observer Pattern**
   - Mendefinisikan ketergantungan satu-ke-banyak antara objek sehingga ketika satu objek mengubah keadaannya, semua objek yang bergantung padanya diberitahu dan diperbarui secara otomatis.
   - Contoh: Penanganan event dalam browser menggunakan `addEventListener`.

### 6. **State Pattern**
   - Mengubah perilaku objek saat status internalnya berubah.
   - Contoh: Implementasi status dalam mesin vending yang mengubah perilaku berdasarkan sisa uang yang dimasukkan.

### 7. **Strategy Pattern**
   - Mengizinkan klien untuk memilih dari beberapa strategi atau algoritma yang berbeda saat melakukan operasi tertentu.
   - Contoh: Penggunaan strategi sorting yang berbeda untuk array berdasarkan ukuran data.

### 8. **Template Method Pattern**
   - Mendefinisikan kerangka kerja untuk sebuah algoritma dalam sebuah metode, dengan memungkinkan subclass untuk mengimplementasikan bagian-bagian dari algoritma.
   - Contoh: Metode `render` dalam framework frontend yang menentukan urutan pemanggilan untuk merender komponen.

### 9. **Visitor Pattern**
   - Memisahkan algoritma dari objek strukturnya, memungkinkan menambahkan operasi baru tanpa mengubah kelas-kelas objek.
   - Contoh: Ekspor data ke format yang berbeda (JSON, XML) tanpa mengubah struktur data utama.

Setiap pola ini menawarkan solusi terstruktur untuk masalah umum dalam desain perangkat lunak yang melibatkan interaksi objek, sehingga memudahkan pengembangan, pemeliharaan, dan memperbaiki sistem dengan memanfaatkan prinsip-prinsip desain yang baik.

### Contoh implementasi

### 1. Chain of Responsibility Pattern
Pattern ini memungkinkan permintaan untuk melewati rantai penangan hingga satu penangan menangani permintaan tersebut.

**Contoh:**
```javascript
class Handler {
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }

  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

class ConcreteHandler1 extends Handler {
  handle(request) {
    if (request === 'Request1') {
      return `Handled by ConcreteHandler1`;
    }
    return super.handle(request);
  }
}

class ConcreteHandler2 extends Handler {
  handle(request) {
    if (request === 'Request2') {
      return `Handled by ConcreteHandler2`;
    }
    return super.handle(request);
  }
}

// Client code
const handler1 = new ConcreteHandler1();
const handler2 = new ConcreteHandler2();
handler1.setNext(handler2);

console.log(handler1.handle('Request1')); // Output: Handled by ConcreteHandler1
console.log(handler1.handle('Request2')); // Output: Handled by ConcreteHandler2
```

### 2. Command Pattern
Pattern ini mengubah permintaan atau operasi menjadi objek mandiri yang memuat semua informasi tentang permintaan itu sendiri.

**Contoh:**
```javascript
class Command {
  execute() {}
}

class Light {
  on() {
    console.log('Light is On');
  }

  off() {
    console.log('Light is Off');
  }
}

class LightOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }

  execute() {
    this.light.on();
  }
}

class LightOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }

  execute() {
    this.light.off();
  }
}

// Client code
const light = new Light();
const lightOnCommand = new LightOnCommand(light);
const lightOffCommand = new LightOffCommand(light);

lightOnCommand.execute(); // Output: Light is On
lightOffCommand.execute(); // Output: Light is Off
```

### 3. Interpreter Pattern
Pattern ini menyediakan cara untuk mengevaluasi bahasa atau notasi tertentu dengan mendefinisikan representasi gramatikalnya dan penafsir yang menggunakan representasi tersebut.

**Contoh:**
```javascript
class Context {
  constructor(input) {
    this.input = input;
    this.output = 0;
  }
}

class Expression {
  interpret(context) {}
}

class NumberExpression extends Expression {
  constructor(number) {
    super();
    this.number = number;
  }

  interpret(context) {
    context.output += this.number;
  }
}

class AddExpression extends Expression {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
  }

  interpret(context) {
    this.left.interpret(context);
    this.right.interpret(context);
    context.output = this.left.number + this.right.number;
  }
}

// Client code
const context = new Context('5 + 3');
const left = new NumberExpression(5);
const right = new NumberExpression(3);
const add = new AddExpression(left, right);

add.interpret(context);
console.log(context.output); // Output: 8
```

### 4. Iterator Pattern
Pattern ini menyediakan cara untuk mengakses elemen-elemen suatu agregat objek secara berurutan tanpa mengekspos representasi dasarnya.

**Contoh:**
```javascript
class Iterator {
  constructor(items) {
    this.index = 0;
    this.items = items;
  }

  hasNext() {
    return this.index < this.items.length;
  }

  next() {
    return this.items[this.index++];
  }
}

// Client code
const items = ['item1', 'item2', 'item3'];
const iterator = new Iterator(items);

while (iterator.hasNext()) {
  console.log(iterator.next());
}
// Output:
// item1
// item2
// item3
```

### 5. Mediator Pattern
Pattern ini mendefinisikan objek yang memediasi interaksi antar objek lainnya untuk mengurangi dependensi antar objek tersebut.

**Contoh:**
```javascript
class Mediator {
  notify(sender, event) {}
}

class ConcreteMediator extends Mediator {
  constructor(component1, component2) {
    super();
    this.component1 = component1;
    this.component2 = component2;
    this.component1.setMediator(this);
    this.component2.setMediator(this);
  }

  notify(sender, event) {
    if (event === 'A') {
      console.log('Mediator reacts on A and triggers following operations:');
      this.component2.doC();
    }
    if (event === 'D') {
      console.log('Mediator reacts on D and triggers following operations:');
      this.component1.doB();
    }
  }
}

class BaseComponent {
  constructor() {
    this.mediator = null;
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }
}

class Component1 extends BaseComponent {
  doA() {
    console.log('Component 1 does A.');
    this.mediator.notify(this, 'A');
  }

  doB() {
    console.log('Component 1 does B.');
  }
}

class Component2 extends BaseComponent {
  doC() {
    console.log('Component 2 does C.');
  }

  doD() {
    console.log('Component 2 does D.');
    this.mediator.notify(this, 'D');
  }
}

// Client code
const component1 = new Component1();
const component2 = new Component2();
const mediator = new ConcreteMediator(component1, component2);

component1.doA();
// Output: 
// Component 1 does A.
// Mediator reacts on A and triggers following operations:
// Component 2 does C.

component2.doD();
// Output:
// Component 2 does D.
// Mediator reacts on D and triggers following operations:
// Component 1 does B.
```

### 6. Memento Pattern
Pattern ini memungkinkan Anda menyimpan dan mengembalikan keadaan sebelumnya dari objek tanpa melanggar enkapsulasi.

**Contoh:**
```javascript
class Memento {
  constructor(state) {
    this.state = state;
  }

  getState() {
    return this.state;
  }
}

class Originator {
  constructor() {
    this.state = '';
  }

  setState(state) {
    this.state = state;
    console.log(`State set to ${state}`);
  }

  save() {
    return new Memento(this.state);
  }

  restore(memento) {
    this.state = memento.getState();
    console.log(`State restored to ${this.state}`);
  }
}

// Client code
const originator = new Originator();
originator.setState('State1');
const savedState = originator.save();

originator.setState('State2');
originator.restore(savedState);
// Output:
// State set to State1
// State set to State2
// State restored to State1
```

### 7. Observer Pattern
Pattern ini mendefinisikan dependensi satu-ke-banyak antara objek sehingga ketika satu objek mengubah statusnya, semua dependennya diberitahu dan diperbarui secara otomatis.

**Contoh:**
```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  notifyObservers() {
    this.observers.forEach(observer => observer.update(this));
  }
}

class Observer {
  update(subject) {}
}

class ConcreteObserver extends Observer {
  update(subject) {
    console.log(`Observer notified by ${subject.constructor.name}`);
  }
}

// Client code
const subject = new Subject();
const observer1 = new ConcreteObserver();
const observer2 = new ConcreteObserver();

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notifyObservers();
// Output:
// Observer notified by Subject
// Observer notified by Subject
```

### 8. State Pattern
Pattern ini memungkinkan objek mengubah perilakunya saat status internalnya berubah. Objek tampak mengubah kelasnya.

**Contoh:**
```javascript
class Context {
  constructor(state) {
    this.transitionTo(state);
  }

  transitionTo(state) {
    console.log(`Transition to ${state.constructor.name}`);
    this.state = state;
    this.state.setContext(this);
  }

  request1() {
    this.state.handle1();
  }

  request2() {
    this.state.handle2();
  }
}

class State {
  setContext(context) {
    this.context = context;
  }

  handle1() {}
  handle2() {}
}

class ConcreteStateA extends State {
  handle1() {
    console.log('ConcreteStateA handles request1.');
    this.context.transitionTo(new ConcreteStateB());
  }

  handle2() {
    console.log('ConcreteStateA handles request2.');
  }
}

class ConcreteStateB extends State {
  handle1() {
    console.log('ConcreteStateB handles request1.');
  }

  handle2() {
    console.log('ConcreteStateB handles request2.');
    this.context.transitionTo(new ConcreteStateA());
  }
}

// Client code
const context = new Context(new ConcreteStateA());
context.request1();
// Output: 
// Transition to ConcreteStateA
// ConcreteStateA
